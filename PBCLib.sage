import hashlib

##########################
# Parameters of the ECC
# p : field characteristic
# Fp: base field
# E : elliptic curve
# fExt: flag
# FE  : extension field

def setECC(fFlag):
    if fFlag == 1:
       p  = 67
       Fp = GF(p)
       b  = 3
       E  = EllipticCurve(Fp, [0, 0, 0, 1, b])
    elif fFlag == 2:
       p  = 59 #211 #11091229 #331 #211 #59
       Fp = GF(p)
       #E  = EllipticCurve(Fp, [0, 0, 0, 1, 0])
       E  = EllipticCurve(Fp, [0, 0, 0, 0, 2])
    elif fFlag == 3:
       p  = 31 #631
       Fp = GF(p)
       a  = 30
       b  = 34
       E  = EllipticCurve(Fp, [a, b])
    elif fFlag == 4:
       p = 103
       A = 1
       B = 18
       E = EllipticCurve(GF(p), [A, B])	 
    else:
       p = 19
       Fp = GF(p)
       E  = EllipticCurve(Fp, [0, 0, 0, 1, 6])
    print '*******************************'
    print '*** Ellip. curve Properties ***'
    print '*******************************'
    print '    E:', E
    print '    Cardinality:', E.cardinality()
    print '    Base Field F:', E.base_field()
    print '    Order:', (E.base_field()).order()

    return E

########################################
# Generate extension of finite field
# R  y: Polynomial Ring over base field Fp
# poly: Irreducible polynomial over Fp
# k  y: degree of pol 
# Fe  : extension of the base field Fp
# Ek  : ECC defined over Fe

###def setFieldExtension(Fp, k):
def setFieldExtension(E, k):
    Fp     = E.base_field()
    R.<x>  = Fp[]
    poly   = R.irreducible_element(k)
    #Fe    = R.quotient_ring(p)
    pk     = (Fp.order())^k
    Fe.<x> = GF(pk, modulus=poly)
    Ek     = E.base_extend(Fe)   
    print '***********************'
    print '*** Field Extension ***'
    print '***********************'
    print '    R:', R
    print '    Irred. poly.:', poly
    print '    Fe:', Fe
    print '    Sanity check, is Fe a field?', Fe.is_field()
    print '    EK:', Ek
    print '    Cardinality:', Ek.cardinality()

    return Fe, Ek

##############################################################
# Return a torsion field generator
# pt: generator
# Fp: base field
# n : order of Fp  
# k : embedding degree of the torsion field
#     generated by pt. It's the degree of the extension of Fp

def setTorsionFieldGenerator(E, fDebug=False, fFlag=-1, fExt=False, fP=-99):
    if fExt == False:
       if fDebug == False:
       	  foo = False
       	  while foo == False:
              	pt = E.random_point()
		if (pt.order()).is_prime() : foo = True  
       else:
	  if   fFlag == 1: pt = E(3, 10)
	  elif fFlag == 2: pt = E(9, 59)
	  elif fFlag == 4: pt = E(33,91)
       	  else :           pt = E(12, 6) 
       Fp = E.base_field()
       n  = Fp.order()
       k  = GF(pt.order())(n).multiplicative_order()
       G1 = [pt*i for i in range(pt.order())]
       print '***********************************************'
       print '*** Generator for the r-torsion subgroup G1 ***'
       print '***********************************************'
       print '    P:', pt
       print '    order:', pt.order()
       print '    G1:', G1
       print '    embedding degree k:', k
       return pt, k, G1
    elif fExt == True:
       foo = False
       G1_EK  = [fP*i for i in range(fP.order())]
       while foo == False:
          for pt in E:
	     #print 'pt', pt, 'order', pt.order()
	     if (pt.order() == fP.order()) and (pt not in G1_EK):
	        foo = True
	       	G2 = [pt*i for i in range(pt.order())]
		break
       print '***********************************************'
       print '*** Generator for the r-torsion subgroup G2 ***'
       print '***********************************************'
       print '    Q:', pt
       print '    order:', pt.order()
       print '    G2:', G2
       return pt, G2, G1_EK
    ###if fDebug == True:
    ###   foo = False
    ###   while foo == False:
    ###       pt = E.random_point()
    ###	   if (pt.order()).is_prime(): foo = True
    ###else:
    ###   if fFlag == 1: pt = E(3, 10)
    ###   else :         pt = E(12, 6) 
    ###Fp = E.base_field()
    ###n  = Fp.order()
    ###k  = GF(pt.order())(n).multiplicative_order()
    ###print '***********************************************'
    ###print '*** Generator for the r-torsion subgroup G1 ***'
    ###print '***********************************************'
    ###print '    P:', pt
    ###print '    order:', pt.order()
    ###print '    embedding degree k:', k
    ###return pt, k

###########################################################
# display the coordinate of the points on E and their order

def displayPointsOnECC(E):
    #if E.cardinality() < 550:
    for pt in E:
        if (pt.order()).is_prime(): print pt, '', pt.order()

###########################################################################
# hashing to G1 subgroup 
# 1. hashing to the whole group E(Fq) using the try-and-increment algorithm
# 2. if necessary, multiply by cofactor so H1
# THE METHOD DEVISED IS NOT CRYPTOGRAPHICALLY SECURE
# HASH COLLISONS ARE LIKELY
# AND THE CONSTRUCTION IS UGLY
# m: message
# h: hash value of the message m
# h_int: h converted into an integer
# c: nonce
# p: field characteristic

def hashToG1(m, E, G1, fFlag):
    p   = (E.base_field()).order()
    foo = False
    c   = 0 #nonce
    while foo == False:
        dummy  = m+str(c)
    	h      = hashlib.sha1(dummy).hexdigest()
	h      = ZZ(map(ord,str(h)),256)     #convert h into an integer 
	h     %= p
	y2     = getY2(h, fFlag)
	y2    %= p
	if y2.is_square() and E(h, sqrt(y2)) in G1:
	   H1 = E(h, sqrt(y2))
	   foo = True
    	else: c += 1
    ###H1 = E(h, sqrt(y2))
    if H1 in G1: return H1
    else:
        print 'H1:',H1, H1 in G1

######################################
# turns ASCII text into a large number

def str2Num(s): return ZZ(map(ord,m),256)

def getY2(x, fFlag):
    if   fFlag == 1: return x*x*x + x + 3
    elif fFlag == 2: return x*x*x + x
    else:            return x*x*x + x + 6